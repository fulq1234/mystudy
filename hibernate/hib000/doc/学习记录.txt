<class name="cn.hibernatedemo.entity" table="`DEPT`">
	<id name="" column="DEPTNO" type="java.lang.Byte">
		<generator class="sequence">
			<param name="sequence">SEQ_DEPTNO</param><!--具体哪个sequence-->
		</generator>

		<generator class="identity"></generator><!--MYSQL/SQL server-->
		<generator class="increment"></generator><!--在数据库中查询最大值,加1-->
		<generator class="native"></generator><!--根据方言自动选择-->

		<generator class="assigned"></generator><!--根据程序赋主键值-->

		<generator class="uuid"></genertor><!--根据实际情况生成一个32位的随机码-->
	</id>
	<property name="dname"></property>
</class>


get,load的区别
1.从返回结果上对比：

load方式检索不到的话会抛出org.hibernate.ObjectNotFoundException异常；
get方法检索不到的话会返回null；

2.从检索执行机制上对比：

load方法的执行则比较复杂首先查找session的persistent Context（一级缓存）中是否有缓存，如果有则直接返回，如果没有则去查找二级缓存，如果有则返回，如果没有则判断是否是lazy，若不是lazy，直接访问数据库检索，查到记录返回（并且同时在二级缓存中存放查到的数据方便下次使用，若再下次使用时在二级缓存命中，就是查到数据，则有可能将数据放到
一级缓存中。），查不到抛出异常。 若是lazy，则返回代理对象，而不到数据库中查找，除非使用此对象时，才到数据库中查找。
get方法先到一级缓存，然后二级，最后db查找。

dynamic-update:
如果是开启了动态更新 那么你在commit之前select到的bean对象,这时再次set不同值进去
然后commit,hibernat会自动判断如果新set的值有变化 那么会执行update操作，那么此时这个
dynamic-update="true" 就表示只update有变化的项,而false默认是全部字段更新

merge和update区别,merge的时候dynamic-update起作用。


not-null="true": 检查空值

持久化对象的几种状态
hibernate中Java对象的三种状态
瞬间状态（Transient）
持久状态（Persistent）
游离状态（Detached）

瞬间状态是一个临时对象，和数据库毫无关系的对象。OID
持久状态是个有用的状态，hibernate会监控这个状态，发现有变化，就进行一些操作。这个状态一定是和数据库有关联的，存到hibernate缓存里面。
游离状态是一个托管对象，从缓存中脱离出去，

刷新缓存就是将数据库同步为与Session缓存一致。
	刷新缓存时会执行脏检查
Session会在以下时间点刷新缓存
	调用Session的flush()方法
	调用Transaction的commit()的方法

更新操作
update()方法
saveOrUpdate()方法
merge()方法

update() 对于持久化对象，可以修改它的属性，然后在清理缓存的时候，执行脏检查。根据修改的情况，执行相关的数据更新
saveOrUpdate()方法 对于游离态对象，直接更新方法。
	如果是临时状态，就执行save方法，如果是游离态状态，就执行update方法
merge()方法，直接对持久化对象的更新。
传参方法传一个游离态对象A，取出id,根据id进行查询，得到持久化状态B,这个时候原来的入参还是游离态，还是安全的。

merge()带有返回值。这个返回值就是持久化对象B,


使用merge(A)添加数据，A是临时对象，创建一个A对象的副本B对象，对副本B对象进行save操作，B对象会保存到数据库中，会变成持久态。而入参A还是临时状态。
保存完以后，B对象会当成返回值返回。


hbm.xml中如果属性名和列表，不考虑大小写的情况下，一样，就可以忽略不写


HQL语句

from cn.Hibernatedemo.entity.Dept
from Dept
from Dept where deptName = 'SALES'
from Dept dept where dept.location is not null
from Emp order by hireDate,salary desc
select deptNo,deptName from Dept

执行HQL语句的步骤
1.获取Session对象
2.编写HQL语句
3.创建Query对象
4.执行查询，得到查询结果。

方法1：
String hql = "from Emp";
Query query = session.createQuery(hql);
List<Emp> empList = query.list();
方法2：
String hql = "from Emp";
Query query = session.createQuery(hql);
Iterator<Emp> empIterator = query.iterate();
方法1就是查询出表中所有数据，方法2是查询出id值。然后直接去缓存里面去找。

String hql = "select count(id) from Emp";
Query query = session.createQuery(hql);
Long count = (Long)query.uniqueResult();//返回唯一结果

在HQL查询语句中绑定参数
使用占位符
1.按参数位置绑定
	from User where name = ?
	session.createQuery("from User where name = ?")
	.setString(0,deptName) //位置从0开始
	.list();
2.按参数名称绑定
	form User where name = :name


